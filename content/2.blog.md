---
author: 王一帅
createTime: '3/27/2023, 12:59:00 AM'
description: '使用 nuxt3 + nuxt content 快速构建个人博客与技术文档'
title: '使用 Nuxt3 构建个人博客'
cover: http://oss.yishuai.wang/imgs/nuxt3-blog-cover.png
avatar: http://oss.yishuai.wang/imgs/avatar.jpeg
---

## 为什么选择 nuxt3 来实现博客

前些天看到 nuxt 团队在 twitter 上发布了 [nuxt3.3的更新博客](https://nuxt.com/blog/v3-3)，里面特别强调了 `DX` 开发者体验，并且多次看到尤大对 nuxt 的推荐，以及一些 nuxt 性能测评，因此决定来尝试一下 [nuxt 3](https://nuxt.com/) 到底给开发者带来了哪些惊喜。

老司机们坐好了嘛？要发车了，Let's go!

## Nuxt 文档一览总结

粗略过完 [nuxt3 文档](https://nuxt.com/docs/getting-started/configuration) 后，与之前使用的 `next.js` 相比，`nuxt3` 具有更多约定式的内容，例如更多的[约定目录](https://nuxt.com/docs/guide/directory-structure/nuxt)，[Auto Imports](https://nuxt.com/docs/guide/concepts/auto-imports) 自动导入，[页面路由](https://nuxt.com/docs/getting-started/routing)、[api 路由](https://nuxt.com/docs/getting-started/data-fetching) 等。

除此之外，nuxt 还提供了一个令人眼前一亮的概念，那就是 [Layer](https://nuxt.com/docs/guide/going-further/layers)，简单来讲，layer 就像 app 级的 `mixin` 一样，我们可以将自己开发的 nuxt app （完整的或部分都可） 作为一个单独的 layer 进行复用，例如 [docus](https://docus.dev/)，封装了一个 markdown 文档应用的 layer，我们在使用的时候，只需要在继承 `docus` 之后，专注于 markdown 文档的书写即可，如果不能满足你，你依然可以像写普通 nuxt 应用一样，在对应目录中追加或覆盖自己需要的功能与组件来满足自己的需求。

除了 `Layer`, nuxt3 还有 `Module` 的概念，Nuxt 提供了一些官方以及社区的优质 [Module](https://nuxt.com/modules), 这些 `Module` 不仅包含了很多有用的库，而且也包含了一些技术方案的封装，例如 [Nuxt Content](https://nuxt.com/modules/content)，提供了一套基于 markdown 文件的 File CSM 解决方案，它也是本次分享的主角之一。与 `Layer` 不同，`Module` 的概念更像是 nuxt 扩展插件，开发者可以在自定义 module 中修改 nuxt 的配置文件，通过 nuxt 提供的钩子函数，可以深度定制 nuxt 的功能，例如实现Vue 插件、CMS、服务器路由、组件、日志记录等。

总的来看，Nuxt 带给我们的内容主要有:

1. 更多的方便的开发约定
2. 自动导入与类型提示
3. Layer 继承复用
4. 丰富的 Module 模块

但也不能说它一点缺点没有：
1. 过多的约定需要我们更多的学习成本，但它不是普适的，学习之后就只是用于nuxt的开发
2. 自动导入、Layer 复用以及深度定制的 Module 固然好用，但体验中看别人的代码有时第一眼会很懵逼，不知道导入来源

不过这些问题并不大，任何技术都是有一定学习门槛的，熟悉之后，用起来是真香。

多数无用，Show Me Coding! 接下来，我们就通过实战从零体验 nuxt 的开发过程吧。

## 初始化一个 nuxt 应用

> 你也可以直接通过 `npx degit yishuai-wang/base-nuxt3 nuxt3-blog` 创建一个本节手把手带着生成的 nuxt3 基础项目模板后，结合代码对本节内容仅做浏览即可，后续实操再进行 coding.

### 创建 nuxt 应用

::code-group

```bash [pnpm]
pnpm dlx nuxi init static-blog
```

```bash [npx]
npx nuxi init static-blog
```
::

> 个人更喜欢 pnpm 一些，所以放在前面了，该说不说，由于安装包尽可能复用缓存，很多时候它安装软件确实快

有人可能好奇 `nuxi` 是什么？

这里补充一下 nuxt 的项目架构，根据官方文档描述，nuxt 是一系列核心包的组合，这些核心包包含以下内容：
- [nuxt](https://github.com/nuxt/nuxt/tree/main/packages/nuxt): 核心引擎
- [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite) 与 [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack): nuxt 打包工具，我们默认使用vite
- [nuxi](https://github.com/nuxt/nuxt/tree/main/packages/nuxi): 命令行工具，创建、启动、打包项目等操作都是通过 `nuxi` 命令执行的
- [nitro](https://github.com/unjs/nitro): 服务端 node 层，顺带提一句，nitro 是 [unjs](https://unjs.io/) 提供的一款用于构建通用node web服务的框架，它的特点这里就不展开说了，这里要重点提到的是 `unjs` 提供了多款优质的前端工具，大家可以多多关注一下，都是大佬们卷出来的好工具，早看早受益。
- `@nuxt/kit` 与 `@nuxt/bridge`：一个是 nuxt 内部核心开发工具包，一个是提升 nuxt2 开发体验到 nuxt3 的 bridge 工具。

### 安装依赖并启动

这里安装依赖仍然单独拿出来主要是像大家推荐一个库 `@antfu/ni`，一个好用到停不下来的小工具，由于现在各种项目我们可能用到 `npm`,`yarn`,`pnpm` 等不同工具，他们安装依赖以及启动时命令都不一致，需要跟随项目的使用工具调整，有时候会让人很头疼，在这个背景下，antfu 大佬开发这个工具，它会自动侦测使用的包管理器（原理是根据 package.lock 文件判断），用统一的命令进行依赖安装与 `package scripts` 的运行，

全局安装 `@antfu/ni`

```bash
npm install -g @antfu/ni
```

进入项目并安装依赖
::code-group
```bash [ni]
cd static-blog && ni
```
```bash [pnpm]
cd static-blog && pnpm install
```
```bash [npm]
cd static-blog && npm install
```
```bash [yarn]
cd static-blog && yarn
```
::

启动项目
::code-group
```bash [ni]
nr dev
```
```bash [pnpm]
pnpm dev
```
```bash [npm]
npm run dev
```
```bash [yarn]
yarn dev
```
::

### 项目规范化

项目创建后，我们需要通过 `eslint` `stylelint` 等工具对代码进行规范化，通过 `commitlint` 结合 `husky` 对 git 提交信息进行一定的规范约束，落地到用工具，强制规范我们的代码与开发流程。

#### eslint 配置

> 关于 eslint 与 prettier 的问题，我们这里不会使用 prettier，原因是 eslint 也可以做到代码的自动修复，我们没必要在 eslint 中强行使用 prettier 插件以及它提供的默认配置，在这个问题上，之前也看到 antfu 大佬的观点，也是大致一样的的，同时 nuxt 文档中也有相似的观点。

安装 `eslint`

::code-group
```bash [ni]
ni eslint @nuxtjs/stylelint-module @antfu/eslint-config -D
```
```bash [pnpm]
pnpm add eslint @nuxtjs/stylelint-module @antfu/eslint-config -D
```
```bash [npm]
npm install eslint @nuxtjs/stylelint-module @antfu/eslint-config -D
```
```bash [yarn]
yarn add eslint @nuxtjs/stylelint-module @antfu/eslint-config -D
```
::

项目中配置 eslint，并在 package.json 中添加 lint 脚本

::code-group
```json [.eslintrc]
{
  "extends": "@antfu"
}
```
```json [package.json]
{
  "scripts": {
    "lint": "eslint ."
  }
}
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/eslint-module',
  ],
})
```
::

在 eslint 配置上，如果你没有封装过自己常用的规则，建议使用 `@antfu/eslint-config`，这也是 antfu 大佬提取的一套常用的规则，虽然其中某些规则跟自己的习惯不太符合，但大多数还是一致的，我们每个人都可以在开发过程中总结出一套自己的 eslint 规则，后续使用时也避免重复配置，总是在初始化项目的时候搞半天，常用的代码模板也是一样的，这也是后续自己也会去做的一件事。

#### stylelint 的配置

除了对 js 代码进行规范化，style 也需要规范化，例如 css 属性的书写顺序等，其实个人使用 stylelint 时主要也是喜欢其 css 属性自动排序的功能。

> stylelint 中依然不推荐使用 prettier，除非你真的很喜欢 prettier，stylelint 的官网也是类似的态度

**安装 stylelint 与相关依赖**

::code-group
```bash [ni]
ni stylelint @nuxtjs/stylelint-module stylelint-config-standard stylelint-config-recess-order stylelint-config-recommended-vue postcss-html -D
```
```bash [pnpm]
pnpm add stylelint @nuxtjs/stylelint-module stylelint-config-standard stylelint-config-recess-order stylelint-config-recommended-vue postcss-html -D
```
```bash [npm]
npm install stylelint @nuxtjs/stylelint-module stylelint-config-standard stylelint-config-recess-order stylelint-config-recommended-vue postcss-html -D
```
```bash [yarn]
yarn add stylelint @nuxtjs/stylelint-module stylelint-config-standard stylelint-config-recess-order stylelint-config-recommended-vue postcss-html -D
```
::

**项目中配置 stylelint**

::code-group
```json [.stylelintrc]
{
  "extends": [
    "stylelint-config-standard",
    "stylelint-config-recess-order",
    "stylelint-config-recommended-vue"
  ]
}
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    ...
    '@nuxtjs/stylelint-module',
    ...
  ],
})

```
::

vscode stylelint 插件配置中也需要添加 vue 到 validate 中，否则不会对 vue sfc 进行检查与代码自动修复

![stylelint plugin](http://oss.yishuai.wang/imgs/stylelint.png)


这些 stylelint 的安装包其实并不复杂，我们来简单看看他们的作用
- `stylelint` 与 `@nuxtjs/stylelint-module` 就不必多说了。
- `stylelint-config-standard` 继承了 stylelint 的推荐配置，并且增加了一些常用的标准规则。
- `stylelint-config-recess-order` 主要是对 css 属性名进行排序，其主要参考了 [css-property-order](https://markdotto.com/2011/11/29/css-property-order/)，犹记当初实习的时候，旁边的外国小哥也对我写 css 的属性顺序有要求，不过当时没有用stylelint 的 autofix，都是死记的 css 属性应该如何排列。
- `stylelint-config-recommended-vue` 也继承了 lstyelint 的推荐配置，并继承了 `stylelint-config-html`，其中通过添加 `postcss-html` 自定义语法，实现在 vue sfc 中对 style 标签也可以进行 lint 与自动修复，除此之外，提供了一些 vue 的推荐配置。

#### commitlint 与 husky 配置

除了使用 eslint 与 stylelint 对代码进行规范化约束，标准化 git 提交信息也是开发一个项目时需要注意的，如果你不能很好地通过个人提交风格来控制 git 提交信息，建议通过 [commitlint](https://conventional-changelog.github.io/commitlint/) 结合 [husky](https://typicode.github.io/husky/#/)，通过工具进行强制约定，保证提交信息的规范。

要注意的是，在使用 husky 时，要保证我们的代码已经通过 git 初始化过，以为它是依赖 git 的钩子的。

```bash
git init
```

::code-group
```bash [ni]
ni @commitlint/cli @commitlint/config-conventional husky lint-staged -D
```

```bash [pnpm]
pnpm add @commitlint/cli @commitlint/config-conventional husky lint-staged -D
```

```bash [yarn]
yarn add @commitlint/cli @commitlint/config-conventional husky lint-staged -D
```

```bash [npm]
npm install @commitlint/cli @commitlint/config-conventional husky lint-staged -D
```
::

**添加 githooks**

```bash
npx husky install # enable git hook
npm pkg set scripts.prepare="husky install" # 向 npm scripts 中添加 prepare：husky isntall
npx husky add .husky/commit-msg  'npx --no -- commitlint --edit ${1}' # 向 commit-msg 钩子添加 commitlint
npx husky add .husky/pre-commit "npx eslint --fix" # 向 pre-commit 添加 eslint 命令,当然如果愿意，你也可以采用 lint-staged
```

**commitlint 与 husky 配置**
::code-group
```json [.commitlintrc]
{
  "extends": ["@commitlint/config-conventional"]
}
```

```bash [.husky/commit-msg]
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx --no -- commitlint --edit ${1}

```
```bash [.husky/commit-msg]
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx eslint --fix

```
::

### 将项目作为基础模板

对于上面的初始化内容，在我们创建任何一个 nuxt 项目可能都是必须的步骤，因此，将其作为我们日后一个开发模板是很有必要的，它可以免除我们日后重复地进行项目配置，提高开发效率。

这里也推荐一下 antfu 大佬自己总结的一些开源的编程模板，基本上都是 [vitesse](https://github.com/antfu?tab=repositories&q=vitesse&type=&language=&sort=) 系列，在开源社区也有比较高的点赞，学习嘛，不光是技术，大佬们的方法也是要学的。

当然，作为一个基础库，我们还可以安装一些自己每个项目中必备的软件，以及基础的模板代码，这里我再安装几个好用的工具，也是作为一个推荐。

> 排名不分先后，脑子里先出现谁谁就在前面，基本也是后续我们都会用到的内容

**No.1**

[Color Mode](https://color-mode.nuxtjs.org/): nuxt 进行主题切换的一个库，文档第一句话就是对自己特别好的介绍："Dark and Light mode with auto detection made easy with Nuxt 🌗"，可以使得明暗模式在nuxt中的自动侦测非常简单。源码也不多，如果感兴趣，后续可以出一些源码阅读的内容，来深入学习一下这些超好用的工具都是如何实现的。

安装：
::code-group
```bash [ni]
ni @nuxtjs/color-mode -D
```

```bash [pnpm]
pnpm add @nuxtjs/color-mode -D
```

```bash [yarn]
yarn add @nuxtjs/color-mode -D
```

```bash [npm]
npm install @nuxtjs/color-mode -D
```
::

配置：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    ...
    '@nuxtjs/color-mode'
    ...
  ]
})
```

**No.2**

[pinceau](https://pinceau.dev/): 强烈推荐，如果我们接触组件库比较多，或者跟设计师朋友、UI小姐姐打交道比较多的话，可能会听说过 Design Tokens，简单来讲，我们的配色方案，组件的大小，形状等信息，在设计师进行 UI 组件库设计的时候，都是有一套标准的，在 UI 主题发生改变的时候，只需要改变这些 Tokens 的值就可以了，你可以将其理解为程序开发时的变量配置文件一样的东西，总之就是将自己的一套设计标准规范化为一套 Token。我们在后面也会专门出个文章来讲，如果比较着急了解，可以看这篇文章 [Design Tokens and how a W3C specification will help going forward](https://backlight.dev/blog/design-tokens)。

pinceau 做的事是就是通过一个配置文件，在其中定义我们自己的 token，之后就可以在我们 app 全局使用相应的变量了，这些变量都会在编译阶段被编译为 css 变量，它支持 [Design Tokens](https://pinceau.dev/configuration/design-tokens), [响应式 Tokens](https://pinceau.dev/configuration/responsive-tokens), [媒体查询 Tokens](https://pinceau.dev/configuration/media-queries), [工具属性](https://pinceau.dev/configuration/utils-properties)，在实现不同主题，响应式页面的时候，会给我们带来非常大的便利，后续也会用到。

安装
::code-group
```bash [ni]
ni pinceau -D
```

```bash [pnpm]
pnpm add pinceau -D
```

```bash [yarn]
yarn add pinceau -D
```

```bash [npm]
npm install pinceau -D
```
::

配置
::code-group
```ts [nuxt.config.ts]
defineNuxtConfig({
  modules: [
    ...
    'pinceau/nuxt'
    ..
  ],
  // 有需要可以配置，暂时可以不要
  // pinceau: {
  //   ...options
  // }
})
```

```ts [tokens.config.ts]
import { defineTheme } from 'pinceau'
export default defineTheme({
  // 具体 token 内容后续使用时配置
})
```
::

pinceau vscode 插件：它可以帮我识别文件中使用 token 的语法以及变量值，并快速跳转到配置文件中
![pinceau vscode plugin](http://oss.yishuai.wang/imgs/pinceau-vscode-plugin.png)

**No.3**

[@unocss/nuxt](https://nuxt.com/modules/unocss): 也是 antfu 大佬开发的一款 原子化 CSS 引擎，官方文档称之为 `The instant on-demand atomic CSS engine.(即时按需的原子 CSS 引擎)`，用法与 tailwind、windi css 基本一致，但它是基于字符串拼接实现的，并且在 vite 构建时通过 transform 直接进行工作，没有额外进行文件扫描，解析为ast的操作，因此效率极高，官方测试速度比 tailwind 与 windi css 快5倍。

感兴趣可以看看 antfu 的博客 [重新构想原子化 CSS](https://antfu.me/posts/reimagine-atomic-css-zh)，有能力的小伙伴推荐看英文原文[Reimagine Atomic CSS](https://antfu.me/posts/reimagine-atomic-css)。在进行本博客开发时，其实看的全都是英文文档，虽然自己英文也不咋地，但目前来说，锻炼一下英文能力，确实对自己去了解一些最新的技术很有帮助，并且 antfu 大佬的博客原文全部是 英文文档。

安装
::code-group
```bash [ni]
ni @unocss/nuxt -D
```

```bash [pnpm]
pnpm add @unocss/nuxt -D
```

```bash [yarn]
yarn add @unocss/nuxt -D
```

```bash [npm]
npm install @unocss/nuxt -D
```
::

配置

```ts
export default defineNuxtConfig({
  modules: [
    ...
    'pinceau/nuxt',
    '@unocss/nuxt',
    ...
  ],
  // pinceau 这里可以加一个配置，可以用来加载 css preset, 这个功能也是依赖 @unocss/reset 的
  pinceau: {
    preflight: 'antfu',
  },
})

```

**No.4**

[nuxt-icon](https://nuxt.com/modules/icon): 基于 [Iconify](https://iconify.design/) 提供了 10w+ 的 icon 供我们使用，不要在死盯着一个 iconfont 来了，这个更好用，基本包含了市面上绝大多数的 icon，例如 element-plus、ant-design 的都会有。

除此之外，再推荐一个 iconify 图标查询工具 [icones](https://icones.js.org/)，也是 antfu 大佬提供的一个更方便的图标查询网站，个人也实在用不惯官方网站的查询，这个工具确实带来了巨大的便捷性。

安装
::code-group
```bash [ni]
ni nuxt-icon -D
```

```bash [pnpm]
pnpm add nuxt-icon -D
```

```bash [yarn]
yarn add nuxt-icon -D
```

```bash [npm]
npm install nuxt-icon -D
```
::

配置

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    ...
    'nuxt-icon'
    ...
  ]
})
```

**No.5**

[nuxt-img](https://v1.image.nuxtjs.org/): nuxt 官方推出的替换 img，picture 元素的开箱即用的组件，并且支持配置多家云厂商 (provider)，统一设置图片资源基础路径等。

安装
::code-group
```bash [ni]
ni @nuxt/image-edge -D
```

```bash [pnpm]
pnpm add @nuxt/image-edge -D
```

```bash [yarn]
yarn add @nuxt/image-edge -D
```

```bash [npm]
npm install @nuxt/image-edge -D
```
::

配置
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    ...
    '@nuxt/image-edge',
    ...
  ]
})
```

**No.6**

[@nuxt/devtools](https://nuxt.com/modules/devtools): nuxt 开发工具，作为 nuxt 应用的开发者，官方提供的开发工具那必须支持一下

安装
::code-group
```bash [ni]
ni @nuxt/devtools -D
```

```bash [pnpm]
pnpm add @nuxt/devtools -D
```

```bash [yarn]
yarn add @nuxt/devtools -D
```

```bash [npm]
npm install @nuxt/devtools -D
```
::

配置
```ts
export default defineNuxtConfig({
  modules: [
    ...
    '@nuxt/devtools',
    ...
  ],
})
```

ok，至此，我们的基础工具也算安装齐全了，我们可以将自己的代码 package.json 中重个名，作为一个基础的项目模板上传到个人仓库中，后续也可以基于此进行不断维护迭代，添加自己常用的一些配置与基础代码模板。

上传到自己仓库后，可以通过 `degit` 来下载自己的模板，通过它可以在 clone 自己的仓库后，自动删除 .git 目录，生成一个不带 git 信息的项目。

使用方式：

```bash
npx degit yishuai-wang/base-nuxt3 nuxt3-blog
# 格式：degit github用户名/仓库名 当前项目名
# 也可以直接将 degit 全局安装到本地，使用更方便
```

## Nuxt Content 助力快速实现博客与技术文档站点搭建

### nuxt 中的路由

nuxt 路由是基于文件系统的路由，这种形式大家已经很常见了，例如 next.js、老版本的 nuxt2、vitepress 等都是基于文件自动生成路由的。

nuxt 会扫描 `/pages` 下的 vue 单文件组件，通过文件名将其映射为路由，当然也是支持动态路由与嵌套路由的，由于其规则比较简单且符合常规文件路由的规则，就不详述其规则了。对于路由命中的文件，nuxt 会通过 `dynamic import` 的方式进行文件导入，通过 `code-spliting` 来装配最少数量的 JavaScript 代码，快速响应页面，提高页面加载速度。

除了 `/pages` 下面的文件会被映射为路由，我们还可以通过安装 [@nuxt/content](https://content.nuxtjs.org/) 模块，将 `/content` 目录下的文件映射为路由，在 `/content` 下，支持将 `markdown`、`YAML/YML`、`CSV` 文件映射为路由，对于 `/pages` 与 `/contents` 下相同名称的文件，`/pages` 下的优先级更高，他们两者是可以共存的。

对于路由涉及到的组件等内容，我们会在后续实战开发用到时穿插讲解。

### Nuxt Content 提供了什么内容

`Nuxt Content` 做的远非一个路由映射，而是基于 nuxt 极高的扩展性，为我们实现了一个基于文件的 (`file-based`) CMS (内容管理系统)，这里我大致总结它为我们提供的内容：

- `/contents` 路经下的路由映射
- `markdown`、`YAML/YML`、`CSV` 等内容的解析
- 通过 `markdown frontmatter`,`YAML/YML`、`CSV` 文件提供页面元数据
- [`MDC` 语法](https://content.nuxtjs.org/guide/writing/mdc)：类似于 mdx，`C` 为 Component，可以在 md 文件中通过 `::compnent-name` 方式渲染组件，以及一些其他扩展
- 一套渲染 markdown 文件解析元素的 [Prose 组件](https://content.nuxtjs.org/api/components/prose)，且可以由开发者灵活覆盖。以及[文件渲染组件](https://content.nuxtjs.org/api/components/content-doc)，包含文章内容渲染、文件列表渲染、导航、内容查询等组件
- 一套类 `MongoDB` 的查询语法
- TypeScript 类型支持

我们可以通过 `markdown frontmatter`，`yaml` 文件等方式提供页面所需的元数据（类似于数据库的数据），配合 nuxt 的 `Layout` 布局系统，对不同类型的页面进行不同的渲染，而不必非要查询数据库，因此 Nuxt Content 才被称为 CMS。当然，nuxt 是及其开放的，我们也可以同时结合数据库对一些动态部分进行渲染。

### nuxt content 初体验

#### 安装与配置

**安装 nuxt content**

::code-group
```bash [ni]
ni @nuxt/content -D
```

```bash [pnpm]
pnpm add @nuxt/content -D
```

```bash [yarn]
yarn add @nuxt/content -D
```

```bash [npm]
npm install @nuxt/content -D
```
::

配置

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    '@nuxt/content'
  ],
  // https://content.nuxtjs.org/api/configuration
  content: {
    highlight: {
      theme: {
        default: 'material-ocean',
        light: 'light-plus'
      }
    },
    markdown: {
      toc: {
        depth: 3,
        searchDepth: 3
      }
    }
  }
})
```

初始配置之后，我们可以在 `/content` 目录中添加一些 `markdown` 文件用于演示，`/pages` 目录需要增加一个 `[...slug].vue` 的 `catch all route` 用于捕获所有的路由，其中会使用到 `<ContentDoc />` 组件，用于渲染匹配到的 markdown 内容。除此之外，我们可以在 `app.vue` 中添加 `<NuxtPage />`，其作用与 vue-router 的 `<RouteView />` 类似，用于渲染匹配到的路由页面。也可以添加`NuxtLink` 组件，跳转到我们指定的 `/content` 下面的具体文件。

代码示例如下（你可以配合上述描述查看沙箱环境中的代码，并根据自己的喜好进行修改）：

::sandbox{src="https://stackblitz.com/github/yishuai-wang/nuxt-blog/tree/lesson/01-add-nuxt-content/?embed=1&file=app.vue&view=both&theme=default"}
::

#### documentDriven 配置
上述我们在 `/pages` 中添加了 `[...slug].vue` 进行所有路由的捕获，当我们开启 `documentDriven` 之后，nuxt-content 将会自动注入该代码，之后你可以删除 `[...slug].vue` 文件，页面依然可以正常运行，除此之外，`documentDriven` 还为我们提供了[布局系统绑定](https://content.nuxtjs.org/guide/writing/document-driven#layout-binding)(通过 frontmatter 指定页面渲染所需的布局)，[全局变量配置](https://content.nuxtjs.org/guide/writing/document-driven#global-variables) 等内容，详情点击对应链接查阅文档。

在我们的实践中，也会开启该选项，尽可能享受 `nuxt content` 带给我们的便利。

配置如下：

```[ts] nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    '@nuxt/content'
  ],
  // https://content.nuxtjs.org/api/configuration
  content: {
    documentDriven: true // 通过上述api可以查阅 documentDriven 更详细的配置
    ...
  }
})
```
> 你可以尝试在上节提供的沙箱环境中修改尝试

#### markdown 主题系统配置

你可以看到，我们上述初始化配置之后，markdown 文件虽然得到了解析，但他们的样式并不好看，我们可以通过 nuxt 官方提供的一套主题 `@nuxt-themes/*` 来对我们当前的渲染进行样式优化。

**安装 `@nuxt-themes/typography`**

::code-group
```bash [ni]
ni @nuxt-themes/typography -D
```

```bash [pnpm]
pnpm add @nuxt-themes/typography -D
```

```bash [yarn]
yarn add @nuxt-themes/typography -D
```

```bash [npm]
npm install @nuxt-themes/typography -D
```
::

`@nuxt-themes/typography` 对 `Nuxt Content` 提供的 `Prose` 组件进行了覆盖重写，如下所见：

![typography 组件](http://oss.yishuai.wang/imgs/nutx-theme-typography.png)

而它本身也是一个 Nuxt 应用，它的结构如图，如果你还记得我们开头提到的 `Layer` 概念，很高兴，我们现在就看到了，对于 `Layer` 的使用，我们可以通过配置文件中的 `extends` 进行添加。

![](http://oss.yishuai.wang/imgs/typography-dir.png)

**配置**

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: ['@nuxt-themes/typography'],
  modules: [
    ...
  ],
  ...
})
```

此时重启项目你会发现页面变得好看了许多。

#### markdwon Compoent 组件扩展

不知道你是否还记得我们前面说的 `mdc` 的概念，`mdc` 类似与 `mdx`，但又不同于 `mdx`，`mdx` 允许我们动态在 markdown 中编导入 `react` 或 `vue` 组件，甚至直接将 md 与 js 混合编写，在解析器的层面对其进行解析最终渲染，mdc 不同于 mdx，它仅仅扩展了 markdown 的语法形式，就算你将 mdc 的内容在普通 markdown 编辑器上进行展示，依然可以展示出内容，仅仅是其扩展语法可能会以原始内容的方式出现。

mdc 的核心其实就是它的 `C(omponent)`，我们可以在自己的应用中编写很多自己预期的组件，最终将 mdc 扩展语法中的数据通过组件渲染出来，Nuxt 官方也在 Nuxt theme 中为我们提供了一套基础的组件 [@nuxt-themes/elements](https://elements.nuxt.space/)。

例如本文中的展示的代码组以及上述引入的沙箱，都是该基础库中帮我们提供的组件。

**安装**

::code-group
```bash [ni]
ni @nuxt-themes/elements -D
```

```bash [pnpm]
pnpm add @nuxt-themes/elements -D
```

```bash [yarn]
yarn add @nuxt-themes/elements -D
```

```bash [npm]
npm install @nuxt-themes/elements -D
```
::

**配置**
与 `@nuxt-themes/typography` 一样，该组件库也是一个 `Layer`，我们直接继承它即可，之后重启项目

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    '@nuxt-themes/typography',
    '@nuxt-themes/elements'
  ],
  ...
})
```

**体验一下 [block-hero 组件](https://elements.nuxt.space/landing/block-hero)**

我们按照文档，复制以下代码到我们 `/content/index.md` 中，删除原来的 `0.index.md`，这里文件名中的 `number.filename.md` 的number 作用是指定文件的排序，在我们去指定一些文章顺序的时候很有用，比如你要写个小册或专栏，需要指定章节顺序，它就很有帮助。

```md [/content/index.md]
::block-hero
---
cta:
  - Goto Hello
  - /hello
secondary:
  - Open on GitHub →
  - https://github.com/nuxtlabs/docus
snippet: npx nuxi init docus-app -t nuxtlabs/docus-starter
---
#title
Document-driven framework
#description
Docus reconciles content creators and developers by offering to both the best tools to create and scale content-based websites.
::
```

此时一股很奇怪的画风会出现在你的眼前，为什么它长得跟官方 demo 不一样？
![](http://oss.yishuai.wang/imgs/hero-page-01.png)

同时你的控制台飘起了一堆奇怪的报错 `missing token`
![](http://oss.yishuai.wang/imgs/desin-token-errors.png)

这是什么东西？？？

别着急，还记得我们在进行项目基本模板搭建时候推荐的工具 `pinceau` 以及提到的 `design tokens` 嘛？这里的报错是因为没有找到对应的 `tokne`，那 `token` 又是什么，直白点讲，它就是一堆我们定义的 css 变量，并且是根据设计规范进行定制的，`@nuxt-themes/elements` 内部依赖了 [`@nuxt-themes/tokens`](https://nuxt-themes-tokens.netlify.app/)，点击链接你可以在线查看到 nuxt-themes 的 design tokens，也就是 nuxt-themes 提供的一套基础的设计规范，并且它也是基于 pinceau 进行这些变量提供与使用的。

我们需要在 nuxt 配置文件中进行配置，切记它需要放在 `modules` 的最上面，否则可能出现样式错误的问题

**安装 `@nuxt-themes/tokens`**

虽然安装 elements 时候也会安装上 tokens，但为了避免隐式依赖，我们还需要显式安装一次。

::code-group
```bash [ni]
ni @nuxt-themes/tokens -D
```

```bash [pnpm]
pnpm add @nuxt-themes/tokens -D
```

```bash [yarn]
yarn add @nuxt-themes/tokens -D
```

```bash [npm]
npm install @nuxt-themes/tokens -D
```
::

**配置**

其实在 `@nuxt-themes/elements` 中已经在配置文件中引用过一次了，但我们这里又配置了很多 module 可能会导致样式出现错误，例如上述错误。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    '@nuxt-themes/elements',
    '@nuxt-themes/typography',
  ],
  modules: [
    '@nuxt-themes/tokens',
    ...
  ],
})

```

除此之外，我们需要删除掉之前在 `tokens.config.ts` 中默认添加的内容，因为其中的 `colors` 会覆盖掉 `@nuxt-themes/tokens` 的配置，最终产生冲突，同时你也可以选择自己的主题色进行配置，默认是 `teal` 青色，我比较喜欢 `ruby` 红宝石色 

```ts [tokens.config.ts]
import { defineTheme } from 'pinceau'
import theme from '@nuxt-themes/tokens/config'

export default defineTheme({
  color: {
    // @ts-expect-error
    primary: theme.color.ruby,
  },
})
```

OK 此时重启项目。

如果此时样式仍未生效，删除 `/node_modules` 后重装依赖再次启动即可

![](http://oss.yishuai.wang/imgs/hero-block-success.png)

### 博客布局组件开发

#### 布局系统初体验

我们看到上述图中，由于整个组件占用了页面所有宽度，导致页面比较丑陋，我们需要限制其展示宽度，大屏时左右留出一些空白。

如果你有印象，我们之前提到了 nuxt 的 `Layout` 布局系统，我们来开发一个默认的布局组件

nuxt 的布局组件需要放在 `/layouts` 下，命名遵循 kebab-cace 的方式，默认的布局为 `default.vue`，在布局组件中，不能直接写 `<slot />`，至少需要包裹一层根元素，例如 `div` ，这是因为在 nuxt 进行布局切换时，可能会有动画，进行布局切换的时候不能仅仅只有 slot.

你可以按照以下方式添加 `/layouts/default.vue` 组件与 `/app.vue` 组件，你可以在 `node_modules` 中找到 `@nuxt-themes/elements` 源码，查看其提供了哪些组件，有些组件在官方文档中未标出，我们也用到了，例如下方的 Container 组件。

::code-group
```vue [/layouts/default.vue]
<template>
  <div>
    <!-- Container 组件是 @nuxt-themes/elements 提供的一款组件 -->
    <Container>
      <slot />
    </Container>
  </div>
</template>
```
```vue [/app.vue]
<script lang="ts" setup></script>

<template>
  <div>
    <header>
      <NuxtLink class="btn" mx-2 my-4 to="/">
        Home
      </NuxtLink>
      <NuxtLink class="btn" to="hello">
        Hello
      </NuxtLink>
    </header>
  </div>
  <!-- 在进行布局组件的应用时，必须添加 <NuxtLayout /> 组件，此时布局组件才会被应用 -->
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```
::

此时页面看起来会舒服很多

![](http://oss.yishuai.wang/imgs/hero-comp-after-layout.png)

#### 全局布局

细心的你可能会发现，在 `/app.vue` 中，我们的在 `NuxtLayout` 组件的同级还写了 `header` 元素，里面的内容不参与布局系统，不管我们在哪个页面，它都会出现，我将其称之为 `全局布局`，例如我们的网站的 `header` `footer` 等内容。

接下来我们就开始进行全局布局，来添加 header 跟 footer 组件。

我们可以在 `/components/app` 中添加全局的布局组件，同时我们要在配置文件中添加对应配置，因为默认的自动导入不会将 `/components` 下面的子目录中的 vue 文件进行自动导入